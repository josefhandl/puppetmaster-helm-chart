#!/bin/bash

set -e

# Set variables
SECRET_NAME_CA="puppet-ca-secret"
SECRET_NAME_SIGNED="puppet-signed-secret"

NAMESPACE="puppet-ns"

DIR_PUPPET_CA="/etc/puppetlabs/puppetserver/ca"
DIR_PUPPET_SIGNED="/etc/puppetlabs/puppetserver/ca/signed"

DIR_BASE="/opt/puppet-scripts"
DIR_TMP="${DIR_BASE}/tmp"
DIR_DUMP="${DIR_BASE}/dump"


function usage() {
    echo "Usage: $0 <command>"
    echo "Save CA or signed certificates generated by Puppet CA to Kubernetes secrets"
    echo ""
    echo "Commands:"
    echo "  save-ca      Create/Patch a Kubernetes secret for CA certificates"
    echo "  save-signed  Create/Patch a Kubernetes secret for signed certificates"
    echo "  help         Show this help message"
    echo ""
    exit 0
}

function check_kubeapi_permissions() {
    PERMISSION="$1"
    kubectl auth can-i "$PERMISSION" secrets --namespace $NAMESPACE 2>/dev/null >/dev/null || { echo "Error: You don't have permissions to manage Kubernetes secrets in the $NAMESPACE namespace!"; exit 1; }
}

function process_secret() {
    # Set secret specific variables
    SECRET_NAME=$1
    DIR_PUPPET=$2
    SECRET_PATH="${DIR_TMP}/${SECRET_NAME}.yaml"

    # Check if Puppet dir exists
    if [ ! -d "$DIR_PUPPET" ]; then
      echo "Error: Directory $DIR_PUPPET does not exist!"
      exit 1
    fi

    # Check permissions to Kubernetes API
    check_kubeapi_permissions "create"
    check_kubeapi_permissions "get"
    check_kubeapi_permissions "list"
    check_kubeapi_permissions "update"
    check_kubeapi_permissions "patch"

    # Prepare tmp dir
    mkdir -p "${DIR_TMP}"
    rm "${DIR_TMP}/*" 2> /dev/null | true

    # Prepare dump dir
    mkdir -p "${DIR_DUMP}"

    # Create new secret file
    echo "apiVersion: v1
kind: Secret
metadata:
  name: $SECRET_NAME
  namespace: $NAMESPACE
type: Opaque
data:" > "$SECRET_PATH"

    # Add each file from the specified directory to the secret
    for FILE_PUPPET_PATH in $(find "${DIR_PUPPET}" -type f); do
        FILE_PUPPET_NAME=$(basename "${FILE_PUPPET_PATH}")
        FILE_PUPPET_BASE64=$(base64 -w0 "${FILE_PUPPET_PATH}")
        echo "  $FILE_PUPPET_NAME: \"$FILE_PUPPET_BASE64\"" >> "$SECRET_PATH"
    done

    # Dump the current state of the secret
    echo "Dumping the current state of the Secret..."
    FILE_SECRET_DUMP="${DIR_DUMP}/${SECRET_NAME}-dump-$(date +%Y-%m-%d-%H-%M-%S).yaml"
    kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o yaml > "$FILE_SECRET_DUMP"
    echo "Secret dump temporary saved to ${FILE_SECRET_DUMP}"
    echo ""

    # Show the current state of the secret
    echo "Old Secret values:"
    echo "----------------------------------------------------------"
    kubectl describe secret "$SECRET_NAME" -n "$NAMESPACE"
    echo "----------------------------------------------------------"
    echo ""

    # Apply the secret to Kubernetes
    echo "Applying the Secret to Kubernetes..."
    kubectl apply -f "$SECRET_PATH"
    echo "Secret '$SECRET_NAME' successfully created in namespace '$NAMESPACE'."
    kubectl get secret "$SECRET_NAME" -n "$NAMESPACE"
    echo ""

    # Show the new state of the secret
    echo "New Secret values:"
    echo "----------------------------------------------------------"
    kubectl describe secret "$SECRET_NAME" -n "$NAMESPACE"
    echo "----------------------------------------------------------"
    echo ""

    echo "Please review the secret values and ensure they are correct."
    echo "Dump of the previous secret is saved in ${FILE_SECRET_DUMP}."
    exit 0
}


if [ $# -eq 0 ]; then
    echo "No arguments provided."
    usage
    exit 1
fi

while [ $# -gt 0 ]; do
    case "$1" in
        save-ca)
            process_secret "$SECRET_NAME_CA" "$DIR_PUPPET_CA"
            ;;
        save-signed)
            process_secret "$SECRET_NAME_SIGNED" "$DIR_PUPPET_SIGNED"
            ;;
        help)
            usage
            ;;
        *)
            echo "Unknown command: $1"
            usage
            ;;
    esac
    shift
done

